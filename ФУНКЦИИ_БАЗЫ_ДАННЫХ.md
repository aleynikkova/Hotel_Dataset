# Объяснение функций и процедур из init_schema.sql

## 1. calculate_booking_price

Вычисляет общую стоимость бронирования на основе ID номера, даты заезда и даты выезда.

```sql
CREATE FUNCTION public.calculate_booking_price(p_room_id integer, p_check_in date, p_check_out date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_price_per_night DECIMAL(10, 2);
    v_nights INTEGER;
    v_total DECIMAL(10, 2);
BEGIN
    --получаем цену за ночь из roomtypes (3NF compliance)
    SELECT rt.price_per_night INTO v_price_per_night
    FROM rooms r
    JOIN roomtypes rt ON r.roomtype_id = rt.roomtype_id
    WHERE r.room_id = p_room_id;
    
    IF v_price_per_night IS NULL THEN
        RAISE EXCEPTION 'Номер с ID % не найден', p_room_id;
    END IF;
    
    --вычисляем количество ночей
    v_nights := p_check_out - p_check_in;
    
    IF v_nights <= 0 THEN
        RAISE EXCEPTION 'Дата выезда должна быть позже даты заезда';
    END IF;
    
    --рассчитываем общую стоимость
    v_total := v_price_per_night * v_nights;
    
    RETURN v_total;
END;
$$;
```

## 2. calculate_total_price_trigger

Триггерная функция для автоматического расчета общей стоимости бронирования при создании или изменении записи.

```sql
CREATE FUNCTION public.calculate_total_price_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_price_per_night DECIMAL(10, 2);
    v_nights INTEGER;
BEGIN
    SELECT rt.price_per_night INTO v_price_per_night
    FROM rooms r
    JOIN roomtypes rt ON r.roomtype_id = rt.roomtype_id
    WHERE r.room_id = NEW.room_id;
    
    v_nights := NEW.check_out_date - NEW.check_in_date;
    
    IF v_nights <= 0 THEN
        RAISE EXCEPTION 'Дата выезда должна быть позже даты заезда';
    END IF;
    
    NEW.total_price := v_price_per_night * v_nights;
    
    RETURN NEW;
END;
$$;
```

## 3. cancel_expired_bookings

Процедура для автоматической отмены просроченных бронирований со статусом 'pending'.

```sql
CREATE PROCEDURE public.cancel_expired_bookings()
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_cancelled_count INTEGER;
BEGIN
    -- Отменяем бронирования со статусом pending, у которых дата заезда прошла
    UPDATE bookings
    SET status = 'cancelled'
    WHERE status = 'pending'
        AND check_in_date < CURRENT_DATE;
    
    GET DIAGNOSTICS v_cancelled_count = ROW_COUNT;
    
    RAISE NOTICE 'Отменено % просроченных бронирований', v_cancelled_count;
END;
$$;
```

## 4. check_booking_availability

Триггерная функция для проверки доступности номера перед созданием или обновлением бронирования.

```sql
CREATE FUNCTION public.check_booking_availability() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_conflict_count INTEGER;
BEGIN
    --проверяем пересечения с существующими бронированиями
    SELECT COUNT(*) INTO v_conflict_count
    FROM bookings
    WHERE room_id = NEW.room_id
        AND booking_id != COALESCE(NEW.booking_id, 0)  -- Исключаем текущее бронирование при UPDATE
        AND status NOT IN ('cancelled')
        AND (
            (check_in_date <= NEW.check_in_date AND check_out_date > NEW.check_in_date)
            OR (check_in_date < NEW.check_out_date AND check_out_date >= NEW.check_out_date)
            OR (check_in_date >= NEW.check_in_date AND check_out_date <= NEW.check_out_date)
        );
    
    IF v_conflict_count > 0 THEN
        RAISE EXCEPTION 'Номер уже забронирован на выбранные даты';
    END IF;
    
    --проверяем, что номер доступен
    IF NOT EXISTS (SELECT 1 FROM rooms WHERE room_id = NEW.room_id AND is_available = TRUE) THEN
        RAISE EXCEPTION 'Номер недоступен для бронирования';
    END IF;
    
    RETURN NEW;
END;
$$;
```

## 5. check_room_availability

Проверяет доступность конкретного номера в указанный период времени.

```sql
CREATE FUNCTION public.check_room_availability(p_room_id integer, p_check_in date, p_check_out date, p_exclude_booking_id integer DEFAULT NULL::integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_conflict_count INTEGER;
BEGIN
    --проверяем, нет ли пересечений с существующими бронированиями
    SELECT COUNT(*) INTO v_conflict_count
    FROM bookings
    WHERE room_id = p_room_id
        AND status NOT IN ('cancelled')
        AND (booking_id != p_exclude_booking_id OR p_exclude_booking_id IS NULL)
        AND (
            (check_in_date <= p_check_in AND check_out_date > p_check_in)
            OR (check_in_date < p_check_out AND check_out_date >= p_check_out)
            OR (check_in_date >= p_check_in AND check_out_date <= p_check_out)
        );
    
    RETURN v_conflict_count = 0;
END;
$$;
```

## 6. get_available_rooms (версия 1)

Возвращает список доступных номеров в указанный период, опционально фильтруя по отелю.

```sql
CREATE FUNCTION public.get_available_rooms(p_check_in date, p_check_out date, p_hotel_id integer DEFAULT NULL::integer) RETURNS TABLE(room_id integer, hotel_id integer, hotel_name character varying, roomtype_id integer, type_name character varying, room_number character varying, floor integer, price_per_night numeric, is_available boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.room_id,
        r.hotel_id,
        h.name AS hotel_name,
        r.roomtype_id,
        rt.type_name,
        r.room_number,
        r.floor,
        rt.price_per_night,
        r.is_available
    FROM rooms r
    JOIN hotels h ON r.hotel_id = h.hotel_id
    JOIN roomtypes rt ON r.roomtype_id = rt.roomtype_id
    WHERE r.is_available = TRUE
    AND (p_hotel_id IS NULL OR r.hotel_id = p_hotel_id)
    AND NOT EXISTS (
        SELECT 1 FROM bookings b
        WHERE b.room_id = r.room_id
        AND b.status IN ('confirmed', 'checked_in')
        AND (
            (b.check_in_date <= p_check_in AND b.check_out_date > p_check_in)
            OR (b.check_in_date < p_check_out AND b.check_out_date >= p_check_out)
            OR (b.check_in_date >= p_check_in AND b.check_out_date <= p_check_out)
        )
    );
END;
$$;
```

## 7. get_available_rooms (версия 2)

Возвращает доступные номера для конкретного отеля с автоматическим расчетом общей стоимости.

```sql
CREATE FUNCTION public.get_available_rooms(p_hotel_id integer, p_check_in date, p_check_out date) RETURNS TABLE(room_id integer, room_number character varying, type_name character varying, price_per_night numeric, total_price numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.room_id,
        r.room_number,
        rt.type_name,
        rt.price_per_night,
        (rt.price_per_night * (p_check_out - p_check_in)) AS total_price
    FROM rooms r
    JOIN roomtypes rt ON r.roomtype_id = rt.roomtype_id
    WHERE r.hotel_id = p_hotel_id
        AND r.is_available = TRUE
        AND NOT EXISTS (
            SELECT 1 FROM bookings b
            WHERE b.room_id = r.room_id
                AND b.status IN ('confirmed', 'checked_in')
                AND (
                    (b.check_in_date <= p_check_in AND b.check_out_date > p_check_in)
                    OR (b.check_in_date < p_check_out AND b.check_out_date >= p_check_out)
                    OR (b.check_in_date >= p_check_in AND b.check_out_date <= p_check_out)
                )
        );
END;
$$;
```

## 8. get_hotel_average_rating

Вычисляет средний рейтинг отеля на основе всех оставленных отзывов.

```sql
CREATE FUNCTION public.get_hotel_average_rating(p_hotel_id integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_avg_rating DECIMAL(3, 2);
BEGIN
    SELECT COALESCE(ROUND(AVG(rev.rating)::numeric, 2), 0)
    INTO v_avg_rating
    FROM reviews rev
    JOIN bookings b ON rev.booking_id = b.booking_id
    JOIN rooms r ON b.room_id = r.room_id
    WHERE r.hotel_id = p_hotel_id;
    
    RETURN v_avg_rating;
END;
$$;
```

## 9. get_hotel_occupancy_stats

Возвращает статистику заполненности отеля за указанный период.

```sql
CREATE FUNCTION public.get_hotel_occupancy_stats(p_hotel_id integer, p_start_date date, p_end_date date) RETURNS TABLE(total_rooms bigint, booked_rooms bigint, available_rooms bigint, occupancy_rate numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    WITH room_stats AS (
        SELECT COUNT(*) as total
        FROM rooms
        WHERE hotel_id = p_hotel_id AND is_available = TRUE
    ),
    booking_stats AS (
        SELECT COUNT(DISTINCT room_id) as booked
        FROM bookings b
        INNER JOIN rooms r ON b.room_id = r.room_id
        WHERE r.hotel_id = p_hotel_id
            AND b.status IN ('confirmed', 'checked_in')
            AND b.check_in_date <= p_end_date
            AND b.check_out_date >= p_start_date
    )
    SELECT 
        rs.total,
        COALESCE(bs.booked, 0) as booked,
        rs.total - COALESCE(bs.booked, 0) as available,
        CASE 
            WHEN rs.total > 0 THEN ROUND((COALESCE(bs.booked, 0)::DECIMAL / rs.total) * 100, 2)
            ELSE 0
        END as rate
    FROM room_stats rs, booking_stats bs;
END;
$$;
```

## 10. set_booking_date

Триггерная функция для автоматической установки даты бронирования.

```sql
CREATE FUNCTION public.set_booking_date() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.booking_date IS NULL THEN
        NEW.booking_date := CURRENT_TIMESTAMP;
    END IF;
    
    RETURN NEW;
END;
$$;
```

## 11. validate_review_rights

Триггерная функция для проверки прав пользователя на добавление отзыва.

```sql
CREATE FUNCTION public.validate_review_rights() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_booking_user_id INTEGER;
    v_booking_status VARCHAR(20);
BEGIN
    --получаем user_id и статус бронирования
    SELECT user_id, status INTO v_booking_user_id, v_booking_status
    FROM bookings
    WHERE booking_id = NEW.booking_id;
    
    --проверка что бронирование существует
    IF v_booking_user_id IS NULL THEN
        RAISE EXCEPTION 'Бронирование не найдено';
    END IF;
    
    --проверяем, что проживание завершено
    IF v_booking_status != 'completed' THEN
        RAISE EXCEPTION 'Отзыв можно оставить только после завершения проживания';
    END IF;
    
    --проверяем, что отзыв еще не был оставлен
    IF EXISTS (SELECT 1 FROM reviews WHERE booking_id = NEW.booking_id AND review_id != COALESCE(NEW.review_id, 0)) THEN
        RAISE EXCEPTION 'Отзыв на это бронирование уже существует';
    END IF;
    
    --устанавливаем дату отзыва
    IF NEW.review_date IS NULL THEN
        NEW.review_date := CURRENT_TIMESTAMP;
    END IF;
    
    RETURN NEW;
END;
$$;
```
